#!/usr/bin/env python

"""
The 46 formulas in Godel's 1931 paper.
"""

godel = {
    '0': 1,     # 0 is just 0, but Godel encodes it as 1
    'f': 3,     # f(n) is successor of n (i.e., n+1), in Godel's notation
    '~': 5,     # ~ is logical 'not'
    'v': 7,     # logical 'or'. we'll use ascii v rather than unicode ∨ (b/c c'mon)
    'Π': 9,     # 'for all' in Godel's notation. (c'mon get a greek keyboard)
    '(': 11,    # left parenthesis
    ')': 13,    # right parenthesis
}

def Eps(max, pred):
    """ Gödel's name for what eventually becomes the μ operator. """
    y = 0
    while y <= max:
        if pred(y):
            return y
        y += 1
    else:
        return 0


def Div(x, y):
    """ 1. x is divisible by y. """
    z = 0
    while z <= x:
        if x == y*z:
            return True
        z += 1
    return False

assert Div(8, 2) == True
assert Div(7, 2) == False
assert Div(5**3, 5**2) == True
assert Div(5**2, 5**3) == False


def Prim(x):
    """ 2. x is a prime number. """
    if not (x > 1):
        return False
    z = 0
    while z <= x:
        if z != 1 and z != x and Div(x, z):
            return False
        z += 1
    return True

assert Prim(1) == False
assert Prim(2) == True
assert Prim(3) == True
assert Prim(4) == False
assert Prim(5) == True
assert Prim(7) == True
assert Prim(9) == False


def nPrx(n, x):
    """ 3. nPrx is the nth (in order of magnitude) prime number contained in x. """
    if n == 0:
        return 0
    pred = lambda y: Prim(y) and Div(x, y) and y > nPrx(n-1, x)
    return Eps(x, pred)

assert nPrx(0, 2*(3**2)*7*11) == 0
assert nPrx(1, 2*(3**2)*7*11) == 2
assert nPrx(2, 2*(3**2)*7*11) == 3
assert nPrx(3, 2*(3**2)*7*11) == 7
assert nPrx(4, 2*(3**2)*7*11) == 11


def Fac(n):
    """ 4. Factorial. """
    if n == 0:
        return 1
    return n*Fac(n-1)


def Pr(n):
    """ 5. Pr(n) is the n-th prime number (in order of magnitude). """
    if n == 0:
        return 0
    return Eps(max=Fac(Pr(n-1)) + 1, pred=lambda y: Prim(y) and y > Pr(n-1))

assert Pr(1) == 2
assert Pr(2) == 3
assert Pr(3) == 5
assert Pr(4) == 7
assert Pr(5) == 11
assert Pr(6) == 13


def nGlx(n, x):
    """ 6. nGlx is the nth term of the series of numbers assigned to x. """
    pred = lambda y: Div(x, nPrx(n, x)**y) and not Div(x, nPrx(n, x)**(y+1))
    return Eps(x, pred)

# x = 2^3 * 3^2 * 5*1 encodes the list [3, 2, 1]
n = (2**3) * (3**2) * (5**1)
assert nGlx(1, n) == 3
assert nGlx(2, n) == 2
assert nGlx(3, n) == 1
assert nGlx(4, n) == 0

# Time: 0.18s

def l(x):
    """ 7. l(x) is the length of the series of numbers assigned to x. """
    pred = lambda y: (nPrx(y, x) > 0) and (nPrx(y+1, x) == 0)
    return Eps(x, pred)

assert l(2*3*5) == 3        # the length of [1, 1, 1] is 3    
assert l(1) == 0            # 1 encodes the empty series
assert l(2**5) == 1         # 2**5 is the singleton list [5]

# Time: 0.18s

#############################################################
### Around this point, we really start to need the caches ###
#############################################################

def join(x, y):
    """ 8. join(x, y) corresponds to "joining together" two finite series of numbers. """

    lx = l(x)
    ly = l(y)
    lxy = Pr(lx + ly)**(x+y)

    def pred1(z):
        return all(nGlx(n, z) == nGlx(n, x) for n in range(lx + 1))

    def pred2(z):
        return all(nGlx(n + lx, z) == nGlx(n, y) for n in range(1, ly + 1))

    def pred(z):
        return pred1(z) and pred2(z)

    return Eps(lxy, pred)

a = 2*3
b = 5
c = 2*3*5
assert join(a, b) == c

a = 2
b = 3*5
c = 2*3*5
assert join(a, b) == c

a = 2*3
b = 5*7
c = 2*3*5*7
assert join(a, b) == c

# Time: 2.5s


def R(x):
    """
        9. R(x) corresponds to the number-series consisting
           only of the number x (for x > 0).
    """
    return 2**x


assert R(5) == 2**5

a = R(2)
b = R(3)
ab = join(a, b)
assert l(ab) == 2
assert nGlx(1, ab) == 2
assert nGlx(2, ab) == 3

# Time: 2.70s



def E(x):
    """ 10. E(x) corresponds to the operation of 'bracketing'. """
    lp = godel['(']         # written 11, in godel's paper
    rp = godel[')']         # written 13, in godel's paper
    R11  = R(lp)            # compute the left-most term
    R13  = R(rp)            # compute the right-most term
    R11x = join(R11, x)     # compute the join "R(11) * x"
    return join(R11x, R13)  # compute "(R(11) * x) * R(13)"


ab = join(R(2), R(3))      # the series (2, 3)
E_ab = E(ab)

assert l(E_ab) == l(ab) + 2

################################
### Time: Still computing... ###
###                          ###
### May be time for a cache. ###
################################

#assert nGlx(1, E_ab) == godel['(']
#assert nGlx(2, E_ab) == nGlx(1, ab)
#assert nGlx(3, E_ab) == nGlx(2, ab)
#assert nGlx(4, E_ab) == 13

